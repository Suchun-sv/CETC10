#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<windows.h>
//#include "my.cpp"
#include<iostream>
#include<stack>
using namespace std;
const int INF=0x7ffffff;
int cost_1[][5] ={32,100,1,0,0,
48,125,0,1,0,
64,150,0,0,1,
80,225,1,1,0,
96,250,0,2,0,
112,275,0,1,1,
128,300,0,0,2,
144,375,0,3,0,
160,400,0,2,1,
176,425,0,1,2,
192,450,0,0,3,
208,525,0,3,1,
224,550,0,2,2,
240,575,0,1,3,
256,600,0,0,4,
272,675,0,3,2,
288,700,0,2,3,
304,725,0,1,4,
320,750,0,0,5,
336,825,0,3,3,
352,850,0,2,4,
368,875,0,1,5,
384,900,0,0,6,
400,975,0,3,4,
416,1000,0,2,5,
432,1025,0,1,6,
448,1050,0,0,7,
464,1125,0,3,5,
480,1150,0,2,6,
496,1175,0,1,7,
512,1200,0,0,8,
528,1275,0,3,6,
544,1300,0,2,7,
560,1325,0,1,8,
576,1350,0,0,9,
592,1425,0,3,7,
608,1450,0,2,8,
624,1475,0,1,9,
640,1500,0,0,10,
656,1575,0,3,8,
672,1600,0,2,9,
688,1625,0,1,10,
704,1650,0,0,11,
720,1725,0,3,9,
736,1750,0,2,10,
752,1775,0,1,11,
768,1800,0,0,12,
784,1875,0,3,10,
800,1900,0,2,11,
816,1925,0,1,12,
832,1950,0,0,13,
848,2025,0,3,11,
864,2050,0,2,12,
880,2075,0,1,13,
896,2100,0,0,14,
912,2175,0,3,12,
928,2200,0,2,13,
944,2225,0,1,14,
960,2250,0,0,15,
976,2325,0,3,13,
992,2350,0,2,14,
1008,2375,0,1,15,
1024,2400,0,0,16,
1040,2475,0,3,14,
1056,2500,0,2,15,
1072,2525,0,1,16,
1088,2550,0,0,17,
1104,2625,0,3,15,
1120,2650,0,2,16,
1136,2675,0,1,17,
1152,2700,0,0,18,
1168,2775,0,3,16,
1184,2800,0,2,17,
1200,2825,0,1,18,
1216,2850,0,0,19,
1232,2925,0,3,17,
1248,2950,0,2,18,
1264,2975,0,1,19,
1280,3000,0,0,20,
1296,3075,0,3,18,
1312,3100,0,2,19,
1328,3125,0,1,20,
1344,3150,0,0,21,
1360,3225,0,3,19,
1376,3250,0,2,20,
1392,3275,0,1,21,
1408,3300,0,0,22,
1424,3375,0,3,20,
1440,3400,0,2,21,
1456,3425,0,1,22,
1472,3450,0,0,23,
1488,3525,0,3,21,
1504,3550,0,2,22,
1520,3575,0,1,23,
1536,3600,0,0,24,
1552,3675,0,3,22,
1568,3700,0,2,23,
1584,3725,0,1,24,
1600,3750,0,0,25,
1616,3825,0,3,23,
1632,3850,0,2,24,
1648,3875,0,1,25,
1664,3900,0,0,26,
1680,3975,0,3,24,
1696,4000,0,2,25,
1712,4025,0,1,26,
1728,4050,0,0,27,
1744,4125,0,3,25,
1760,4150,0,2,26,
1776,4175,0,1,27,
1792,4200,0,0,28,
1808,4275,0,3,26,
1824,4300,0,2,27,
1840,4325,0,1,28,
1856,4350,0,0,29,
1872,4425,0,3,27,
1888,4450,0,2,28,
1904,4475,0,1,29,
1920,4500,0,0,30,
1936,4575,0,3,28,
1952,4600,0,2,29,
1968,4625,0,1,30,
1984,4650,0,0,31,
2000,4725,0,3,29,
2016,4750,0,2,30,
2032,4775,0,1,31,
2048,4800,0,0,32,
2064,4875,0,3,30,
2080,4900,0,2,31,
2096,4925,0,1,32,
2112,4950,0,0,33,
};
int cost_2[][2]={32,100,
48,125,
64,200,
80,225,
96,250,
112,325,
128,350,
144,375,
160,450,
176,475,
192,500,
208,575,
224,600,
240,625,
256,700,
272,725,
288,750,
304,825,
320,850,
336,875,
352,950,
368,975,
384,1000,
400,1075,
416,1100,
432,1125,
448,1200,
464,1225,
480,1250,
496,1325,
512,1350,
528,1375,
544,1450,
560,1475,
576,1500,
592,1575,
608,1600,
624,1625,
640,1700,
656,1725,
672,1750,
688,1825,
704,1850,
720,1875,
736,1950,
752,1975,
768,2000,
784,2075,
800,2100,
816,2125,
832,2200,
848,2225,
864,2250,
880,2325,
896,2350,
912,2375,
928,2450,
944,2475,
960,2500,
976,2575,
992,2600,
1008,2625,
1024,2700,
1040,2725,
1056,2750,
1072,2825,
1088,2850,
1104,2875,
1120,2950,
1136,2975,
1152,3000,
1168,3075,
1184,3100,
1200,3125,
1216,3200,
1232,3225,
1248,3250,
1264,3325,
1280,3350,
1296,3375,
1312,3450,
1328,3475,
1344,3500,
1360,3575,
1376,3600,
1392,3625,
1408,3700,
1424,3725,
1440,3750,
1456,3825,
1472,3850,
1488,3875,
1504,3950,
1520,3975,
1536,4000,
1552,4075,
1568,4100,
1584,4125,
1600,4200,
1616,4225,
1632,4250,
1648,4325,
1664,4350,
1680,4375,
1696,4450,
1712,4475,
1728,4500,
1744,4575,
1760,4600,
1776,4625,
1792,4700,
1808,4725,
1824,4750,
1840,4825,
1856,4850,
1872,4875,
1888,4950,
1904,4975,
1920,5000,
1936,5075,
1952,5100,
1968,5125,
1984,5200,
2000,5225,
2016,5250,
2032,5325,
2048,5350,
2064,5375,
2080,5450,
2096,5475,
2112,5500,
};
int cost_3[][2]={
    32,100,
64,200,
96,300,
128,400,
160,500,
192,600,
224,700,
256,800,
288,900,
320,1000,
352,1100,
384,1200,
416,1300,
448,1400,
480,1500,
512,1600,
544,1700,
576,1800,
608,1900,
640,2000,
672,2100,
704,2200,
736,2300,
768,2400,
800,2500,
832,2600,
864,2700,
896,2800,
928,2900,
960,3000,
992,3100,
1024,3200,
1056,3300,
1088,3400,
1120,3500,
1152,3600,
1184,3700,
1216,3800,
1248,3900,
1280,4000,
1312,4100,
1344,4200,
1376,4300,
1408,4400,
1440,4500,
1472,4600,
1504,4700,
1536,4800,
1568,4900,
1600,5000,
1632,5100,
1664,5200,
1696,5300,
1728,5400,
1760,5500,
1792,5600,
1824,5700,
1856,5800,
1888,5900,
1920,6000,
1952,6100,
1984,6200,
2016,6300,
2048,6400,
2080,6500,
2112,6600,
};
int flow_1[21]={
636,
141,
236,
119,
28,
132,
84,
109,
71,
95,
97,
30,
35,
57,
31,
39,
50,
37,
40,
32,
15,
};
int vis[500][500]={0}; 
double dis[21][21]={0,96.46,108.45,40.3,45.12,76.85,356.94,417.49,62.82,107.87,293.63,182.23,260.61,127.25,238.09,111.63,243.35,289.09,84.82,144.74,228.35,
96.46,0,14.18,58.07,132.33,32.72,268.5,329.57,49.79,29.2,384.89,87.97,350.73,33.98,152.93,86,325.56,378.84,163.27,238.59,134.9,
108.45,14.18,0,71.17,145.7,37.98,254.43,315.49,56.28,20.54,398.39,74.5,364.35,30.42,138.74,97.19,339.62,392.51,177.24,251.6,121.31,
40.3,58.07,71.17,0,74.59,47.19,324.23,385.17,41.74,75.08,327.33,145.67,293.43,87.28,206.63,81.69,270.7,321.67,108.09,180.54,192.43,
45.12,132.33,145.7,74.59,0,118.76,398.4,459.24,106.71,148.76,252.74,220.19,218.9,158.91,280.21,118.2,198.74,247.2,40.37,106.83,267,
76.85,32.72,37.98,47.19,118.76,0,280.2,340.86,18.36,31.25,370.32,107.01,337.04,66.05,161.58,106.26,316.82,365.46,154.58,221.6,152.24,
356.94,268.5,254.43,324.23,398.4,280.2,0,61.08,294.7,249.67,650.51,182.34,617.15,251.25,119.18,332.36,594.05,645.53,431.6,501.55,136.57,
417.49,329.57,315.49,385.17,459.24,340.86,61.08,0,355.06,310.49,711.12,243.33,677.88,312.11,179.43,392.65,655.11,706.29,492.64,561.95,197.3,
62.82,49.79,56.28,41.74,106.71,18.36,294.7,355.06,0,48.3,356.21,124.42,323.36,83.64,175.64,113.48,305.44,351.86,144.4,206.89,168.98,
107.87,29.2,20.54,75.08,148.76,31.25,249.67,310.49,48.3,0,400.98,76.12,367.49,49.79,131.6,115.19,345.78,395.86,183.15,252.58,121.01,
293.63,384.89,398.39,327.33,252.74,370.32,650.51,711.12,356.21,400.98,0,472.84,35.37,409.45,531.72,348.16,87.13,15.93,224.1,149.76,519.7,
182.23,87.97,74.5,145.67,220.19,107.01,182.34,243.33,124.42,76.12,472.84,0,438.71,69.26,74.22,152.56,412.68,466.81,250.9,326.03,46.97,
260.61,350.73,364.35,293.43,218.9,337.04,617.15,677.88,323.36,367.49,35.37,438.71,0,374.79,498.59,312.81,58.19,28.54,189.23,118.36,485.63,
127.25,33.98,30.42,87.28,158.91,66.05,251.25,312.11,83.64,49.79,409.45,69.26,374.79,0,141.69,84.36,345.82,402.53,185.7,265.74,114.86,
238.09,152.93,138.74,206.63,280.21,161.58,119.18,179.43,175.64,131.6,531.72,74.22,498.59,141.69,0,225.91,477.26,527.02,314.6,382.53,45.63,
111.63,86,97.19,81.69,118.2,106.26,332.36,392.65,113.48,115.19,348.16,152.56,312.81,84.36,225.91,0,276.1,339.13,128.22,216.5,196.03,
243.35,325.56,339.62,270.7,198.74,316.82,594.05,655.11,305.44,345.78,87.13,412.68,58.19,345.82,477.26,276.1,0,72.93,162.66,117.86,459.54,
289.09,378.84,392.51,321.67,247.2,365.46,645.53,706.29,351.86,395.86,15.93,466.81,28.54,402.53,527.02,339.13,72.93,0,216.84,146.81,513.75,
84.82,163.27,177.24,108.09,40.37,154.58,431.6,492.64,144.4,183.15,224.1,250.9,189.23,185.7,314.6,128.22,162.66,216.84,0,88.79,297.87,
144.74,238.59,251.6,180.54,106.83,221.6,501.55,561.95,206.89,252.58,149.76,326.03,118.36,265.74,382.53,216.5,117.86,146.81,88.79,0,372.56,
228.35,134.9,121.31,192.43,267,152.24,136.57,197.3,168.98,121.01,519.7,46.97,485.63,114.86,45.63,196.03,459.54,513.75,297.87,372.56,0,};
queue <int> q;
struct fiber {
    int distance =0;
    int cap = 0;
    int cost =0;
};
int n,m,x,y,s,t,gg[201][201]={0},g[201][201]={0},pre[201],flow[201],maxflow; 
int num_road = 0;
fiber f[3];
void up_the_road(int x,int y);
}
stack<int> ss;
int num[]={7,6,14,9,20,11,13,2,15}; 
int maxx[500]={0};
void showPath();
int update_flag = 1;//标记最大流的更新是否开始 
int dfs_update(int i,int j)
{
	int used[500]={0};
	int que[50][50];
	int cnt = 0;
	while(!ss.empty()) ss.pop();
	ss.push(i);
	memset(pre,-1,sizeof(pre));
	int temp = ss.top();
	int y=0;
	int x = 0;
		if(x) showPath();
	while(ss.size())//目的是遍历整张图更新所有为0的节点emm 
	{
		temp = ss.top();
		if(x) cout<<temp<<" "; 
		int flag = 1;
		for(int ii=0;ii<50;ii++)
		{
			if(gg[ii][temp]>0&&used[ii]==0)
			{
				ss.push(ii);
				used[ii]=1;
				pre[ii] = temp;
				temp =ss.top();
				flag = 0;
				break;
			}
			if(temp!=j&&gg[ii][temp]==0&&g[ii][temp]>0)
			{
				up_the_road(ii,temp);
		if(x)		cout<<"更新了"<<ii<<" "<<temp<<endl; 
			}
		}
		if(flag) ss.pop();
	}
}
int dfs(int i,int j)
{

	int used[500]={0};
	int que[50][50];
	int cnt = 0;
	while(!ss.empty()) ss.pop();
	ss.push(i);
	memset(pre,-1,sizeof(pre));
	int temp = ss.top();
	int y=0;
	y=1;
	int x = 0;
	x =1;
	if(update_flag==1||1)
	{
		x=0;
		y=0;
	}
	if(x) cout<<endl<<"**************************dfs**********************"<<endl;
		if(x) showPath();
	while(temp!=j&&ss.size())
	{
		temp = ss.top();
		if(x) cout<<temp<<" ";
		int flag = 1;
		for(int ii=0;ii<50;ii++)
		{
			if(gg[temp][ii]>0&&used[ii]==0)
			{
				ss.push(ii);
				used[ii]=1;
				pre[ii] = temp;
				temp =ss.top();
				flag = 0;
				break;
			}
			if(temp!=i&&gg[temp][ii]<=0&&g[temp][ii]>0)
			{
				que[cnt][0]=temp;
				que[cnt++][1]=ii;
			}
		}
		if(flag) ss.pop();
	}
if(x)	cout<<endl;

	int increse = 0x3f3f3f;
	if(temp==j)
	{
		while(temp!=i)
		{
			increse = min(gg[pre[temp]][temp],increse);
			temp = pre[temp];
			if(pre[temp]==i) maxx[temp]=1;
		}
	if(x)	cout<<endl<<"increse:"<<increse<<endl;
		return increse;
	}

	if(temp!=j)
	{
		int flag = 0;
		for(int i=0;i<sizeof(num)/sizeof(int);i++)
		{
			if(maxx[num[i]] == 0) flag = 1;
	if(x)		cout<<maxx[num[i]]<<" ";
			update_flag = flag;
		}
	if(x)	cout<<endl;
		if(flag) dfs_update(1,50);
	}
	return -1;
}
int EK(int s,int t)
{
	memset(maxx,0,sizeof(maxx));
#ifdef LOCAL
freopen("C:/Users/hsxny/Desktop/shuru.txt","r",stdin);
#endif
    maxflow = 0;
    int x = 0;
    int increase=0;
  if(x)  cout<<endl<<"new_time****************************"<<endl;
    while ((increase=dfs(s,t))!=-1)
    {//迭代 
     int flag = 0,min_x=0,min_y=0,temp=0x3f3f3f;
 if(x)   	cout<<"值为"<<increase<<":"<<endl;
        int k=t;
        while (k!=s)
        {
        	
            int last=pre[k];//从后往前找路径
            gg[last][k]-=increase;
            gg[k][last]+=increase;
            if(gg[last][k]==0&&last!=s)
			{
				min_x = last;
				min_y = k;
			} 
			if(x) cout<<last<<" "<<k<<" "<<gg[last][k]<<" "<<g[last][k]<<endl;
			if(last == s)
			{
				if(gg[last][k]!=0) flag =1;
			}

            k=last;
if(x)        cout<<k<<endl;
        }
        maxflow+=increase;
      if(x)  			cout<<update_flag<<flag<<"**********************"<<endl;
			if(!update_flag&&flag) 
			{
if(x)				cout<<"The world die"<<min_x<<" "<<min_y<<endl;
				up_the_road(min_x,min_y);
			}
    }
    return maxflow;
}
struct node{
    int x;
    int y;
    int z;
    int k = 0;
    int cost=0;
bool operator <(const node& y) const
{
    return z<y.z;
}
};
node path[50*50];
int update(node& path)
{
    int distance = dis[path.x][path.y];
    if(distance<80)
    {   
        path.z = cost_1[path.k][0];
        path.cost = cost_1[path.k++][1];
        g[path.x][path.y] = path.z;
        return path.z;
    }
    if(distance<100)
    {
        path.z = cost_2[path.k][0];
        path.cost = cost_2[path.k++][1];
        g[path.x][path.y] = path.z;
        return path.z;
    }
        path.z = cost_3[path.k][0];
        path.cost = cost_3[path.k++][1];
        g[path.x][path.y] = path.z;
        return path.z;
}
void up_the_road(int x,int y)
{
	if(vis[x][y]) return;
    for(int i=0;i<num_road;i++)
    {
        node& temp = path[i];
        if(temp.x == x&&temp.y == y)
        {
        	
            update(temp);
            vis[x][y]=1;
            break;
        }
       if(temp.y == x&&temp.x == y)
        {
        	cout<<"错误"<<endl;	
        }
    }
    return;
}
void init()
{
   f[0].cap = 32;
   f[0].cost= 1 ;
   f[0].distance = 200;

   f[1].cap = 48;
   f[1].cost= 1.25 ;
   f[1].distance = 100;

   f[2].cap = 64;
   f[2].cost= 1.5 ;
   f[2].distance = 80;
}
void fresh()
{
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=50+5;i++)
	for(int j=0;j<=50+5;j++)
	gg[i][j]=g[i][j];
}
void showPath()
{
	int ans=0;
	cout<<endl<<"***************Path is************************"<<endl;
	      for(int j=0;j<num_road;j++)
	{
		cout<<"path:"<<path[j].x<<" "<<path[j].y<<" "<<path[j].z<<" "<<gg[path[j].x][path[j].y]<<" "<<dis[path[j].x][path[j].y]<<" "<<path[j].cost/100<<endl;
		ans+=path[j].cost;
	}
	cout<<"cost:"<<ans/100<<endl;
}
int main()
{
#ifdef LOCAL
freopen("C:/Users/hsxny/Desktop/shuru.txt","r",stdin);
#endif
	cout<<"start"<<endl;
    init();
    int ans =0;
    for(int i=0;i<sizeof(num)/sizeof(int);i++)
    {
        ans+=flow_1[num[i]];
        g[50][num[i]]=flow_1[num[i]];
    }
    cout<<ans<<endl;
    int i=0;
    while(scanf("%d%d",&x,&y)==2&&x+y!=0)
    {
        path[i].x = x;
        path[i].y = y;
        path[i].k = 0;
        update(path[i]);
        i++;
    }
    n=1;
    num_road = i;
    cout<<i<<endl;
	int cntt=2;
	fresh();
    while(EK(50,1)<ans)
    {
    	fresh();

    }
	showPath();
    return 0;
}
